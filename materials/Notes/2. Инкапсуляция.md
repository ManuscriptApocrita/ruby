2. Инкапсуляция
========================
Инкапсуляция (от лат. in capsule — в оболочке) -  свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе (заключение данных и функциональности в оболочку). В роли оболочки выступают классы: они не только собирают переменные и методы в одном месте, но и защищают их от вмешательства извне (сокрытие). В статьях по этой теме может приводиться пример с защитой путем инкапсуляции обновления переменных класса, это тоже имеет место быть, ведь в этом случае создаются дополнительные проверки и функциональность помещается в *безопасную оболочку*. Сокрытие (ограничение доступа различных частей программы к внутренним компонентам друг друга) это вытекающее из инкапсуляции, ведь именно инкапсуляция предоставляет возможность использования сокрытия.

*Инкапсуляция нужна, чтобы обеспечить целостность объекта и дать возможность пользоваться им, не вдаваясь в подробности его реализации.*

**Методы имеют несколько разновидностей сокрытия:**

public - Область видимости в пределах класса, экземпляра класса и всех потомков класса (по умолчанию все методы публичные)

protected - Область видимости внутри класса и всех его потомков 

private - модификатор доступа, который делает областью видимости - только внутри класса

private :some_method,
protected :some_method 

```
class Storage #класс - результат инкапсуляции
  def initialize(toys, notebooks)
    @toys = toys
    @notebooks = notebooks
  end

  attr_reader :toys, :notebooks

  def examine_variable(variable)
    if variable < 0 || variable.is_a?(Integer) == false
      false
    else
      true
    end
  end

  private :examine_variable #здесь применяется сокрытие метода, видимость - только в классе

  def change_value(name, value)
    case name
    when "toys"
      if examine_variable(value)
        @toys = value
      end
    when "notebooks"
      if examine_variable(value)
        @notebooks = value
      end
    else
      nil
    end
  end
end

aaron_shop = Storage.new(10, 15)

puts "Toys in SHOP - #{aaron_shop.toys}"
puts "Notebooks in SHOP - #{aaron_shop.notebooks}"

aaron_shop.change_value("toys", 1) #проверка будет пройдена и переменная класса изменится
aaron_shop.change_value("toys", -10) #переменная не изменится, потому что входные данные не прошли проверку
aaron_shop.change_value("toyz", 3) #не изменится, и, что важно, не будет ошибки
aaron_shop.change_value("notebooks", 1)
aaron_shop.change_value("notebooks", -10)
aaron_shop.change_value("notebookz", 3)

#использование метода change_value наглядно демонстрирует использование результата инкапсуляции,

puts "\nToys in SHOP after change - #{aaron_shop.toys}"
puts "Notebooks in SHOP after change - #{aaron_shop.notebooks}"

# shop_one.examine_variable(1) вызов метода не сработает, его область видимости - только класс
```

